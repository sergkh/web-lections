Робота з об’єктами в Javascript
------
В Javascript реалізовано основні елементи ООП. Так Javascript крім примітивних типів підтримує роботу з об’єктами. Об’єкти в Javascript представляють собою асоціативний масив. В ньому ключам (зазвичай стрічковим) відповідає значення або функція. Створювати об’єкти в Javascript можна так як і в Java та С++ використовуючи оператор `new`:

    var obj1 = new Object();

Вираз створить новий об’єкт `obj1`. `Object` - стандартний об’єкт в js. Додамо поля до об’єкту, поля додаються динамічно:

    obj1.num1 = 15;
    obj1.strField = 'Field value';

    obj1.getName = function() {
        return this.name;
    }

Далі до даних полів можна доступатись в коді наступним чином:

    alert(obj1.num1);
    alert(obj1.getName());

Альтернативним способом доступу до полів є доступ до полів, як до асоціативного масиву:

    obj['fld4'] = '4th field';
    alert(obj['fld4']);

Такий спосіб зручний якщо ім’я поля є недопустимим для вказання імені змінної або ж отримується динамічно.

Літеральна нотація
---------
З версії 1.3 в Js з’явився інший спосіб об’явлення об’єктів, який є більш зручним і простішим для розуміння - літеральна нотація. Поля об’єкту перелічуються в фігурних дужках через кому у вигляді `{ field: value, ... }`. Приклад створення об’єкту з використанням літеральної нотації:

    var obj2 = {
        num : 19,
        name : 'Sample',
        flag : false,
        getName : function() {
            return this.name;
        }
    } 

Якщо ім’я поля є недопустимим ім’ям змінної, його можна взяти в лапки:

    var obj3 = { '123' : 123 }

Також в javascript функції та масиви теж можна використовувати як об’єкти, тобто 3 наступні об’єкти будуть ідентичними й відрізнятимуться тільки типом (об’єкт, масив та функція):

    var obj = {};
    var arr = [];
    var fn = function(){}
    
    obj.id = 1;
    arr.id = 2;
    fn.id = 3;

Конструктори об’єктів
------

В JS немає класів, однак нові об’єкти можна описувати за допомогою функцій-конструкторів. Конструктор — це функція, яка викликається при створенні об’єкту, в Javascript такі функції використовуються для створення нових об’єктів. Фактично оскільки функцію також дозволяється використовувати як звичайний об’єкт, то можна написати функцію:

    function UserObject(id, name) {
        this.id = id;
        this.name = name;
    }

Тобто функцію, яка сама визначить необхідні поля об’єкту відповідно до значень аргументів функції. Далі для створення нового об’єкту за допомогою даної функції необхідно її викликати з оператором `new`:

    var obj5 = new UserObject(1, 'First user');
    var obj6 = new UserObject(2, 'Second user');

Таким чином можливо створювати скільки завгодно об’єктів на основі даної функції й зміна значень `obj5` ніяк не вплине на дані об’єкту `obj6`.

Розлянемо приклад стоврення об’єкту з значеннями за замовчуванням та методами:

    function Post(id, title, text) {
        this.id = id;
        this.title = title;
        this.text = text;
        this.changeDate = new Date();
        
        this.update = function(title, text) {
            this.title = title;
            this.text = text;
            this.changeDate = new Date();
        }
    }

    var post = new Post(1, 'Відкриття', 'Перший пост');
    post.update('Відкриття', 'Пост оновлено');

Прототипи
-------

В Javascript реалізований особливий варіант наслідування - наслідування на основі прототипів. Суть прототипного наслідування у тому, що один об’єкту можна встановити прототипом інший об’єкт й якщо якась властивість чи метод не знайдено в першому об’єкті, то інтерпретатор буде продовжувати пошук у прототипі цього об’єкту, далі якщо й там немає, то у прототипі прототипу і т. д.

Доступ до прототипу об’єкту реалізовано через властивість `prototype`. Розглянемо приклад:

    <script type="text/javascript">
        function Human() {
            this.id = 0;
        	this.talk = function() {
        		alert(this.name);
        	}
        }
        
        function User(name) {
    	    this.name = name;
        }
        
        var john = new User('John Deere');
    
        User.prototype = new Human(); // Змінимо прототип об’єктів User
    
        var thomas = new User('Thomas Erak')
        thomas.talk();
    
        john.talk(); // <-- Exception here
    </script>

В даному прикладі створено два методи констуктора та 3 об’єкти: `john`, `new Human()` та `thomas`. Об’єкт `new Human()` встановлюється прототипом для об’єктів типу `User` й після чого якщо у об’єктів типу `User` не буде знайдено певної властивості чи методу - пошук автоматично відбудеться у об’єкті типу `Human`. Таким чином у об’єкту `thomas` можна використовувати метод `talk()` та поле `id` - вони будуть знайдені у прототипі. Й не важливо що на момент визначення ф-ції `talk()` поля `name` не визначено в жодному з об’єктів - інтерпретатору головне тільки щоб дане поле було визначене саме на момент виклику функції.

Однак слід зауважити що об’єкт `john` був створений раніше - до того, коли у `User` прототипом став `Human`, тому прототипом у нього так і залишився об`єкт `User` й доступу до даного методу відповідно не з’явиться. За замовчуванням прототипом об’єкту прототипом буде сама функція, `User`, в неї прототипом буде `Object`, а вже в нього поле прототип дорівнює null:

    john.prototype -> User  
    User.prototype -> Object
    Object.prototype -> null

Можна додавати властивості простіше, не будемо заміняти об’єкт прототип, а просто додамо до нього нову властивість:

    function User(name) {
    	this.name = name;
    }

    var john = new User('John Deere');
    
    User.prototype.firstName = function() {
    	return this.name.split(" ")[0];
    };
    
    var thomas = new User('Thomas Erak');
    
    alert(thomas.firstName());
    alert(john.firstName());

В даному прикладі ми не замінюємо безпосередньо об’єкт прототипу у класу User, а просто додаємо до нього новий метод, тому вже обидва об’єкти матимуть новий метод. Даний приклад відобразить 2 діалогових вікна з текстом `Thomas` та `John`.

Даний механізм дозволяє робити неймовірні, як для C++ чи Java речі - змінюючи прототипи можна додавати нові функції до вбудованих об’єктів таких як String, Array чи Object. Розглянемо приклад:

В Java є зручна функція `startsWith`, що дозволяє перевірити чи стрічка починається з іншої стрічки:

    "Kevin".startsWith("Ke") = true

В Javascript є тільки функція `indexOf(str)`, але використовуючи її та прототипи можна легко додати корисну функціональність:

    if(!String.prototype.startsWith){
        String.prototype.startsWith = function (str) {
            return this.indexOf(str) == 0;
        }
    }

Спочатку перевіряється чи функція не була визначена раніше - наприклад з’явилась в новій версії Javascript чи була вже визначена раніше. Якщо функції не існувало `String.prototype.startsWith` буде дорівнювати `undefined` що інтерпретатор приведе до `false`. Далі функція визначається для об’єкту прототипу й все - тепер її можна використовувати в будь-яких стрічках:

    var flag = "Kevin".startsWith("Ke");
    
Ну й ще один приклад додавання існуючої функції, яка порахує кількість слів у стрічці:

    function getWordsCount() {
        return this.split(" ").length;
    }

    String.prototype.getWordsCount = getWordsCount;

Використання:

    var str = "Text with four words";
    alert(str.getWordsCount()); 
    
Результат буде - 4.

Замикання
------

Замикання - це внутрішня функція разом з своїм контекстом виконання. Тобто якщо маємо функцію, що містить в собі ще одну функцію, то внутрішння функція має доступ до змінних та методів, зовнішньої, при чому навіть за областю видимості цих змінних. Розглянемо це на прикладі:

    var v1 = 'Outer';
    function messageBuilder(v2) {
        var v3 = 'Inner';

        return function() {
            return v1 + ' ' + v2 + ' ' + v3;
        }
    }

    var bldr = messageBuilder('Arg');

    var str = bldr(); // Поверне 'Outer Arg Inner'

В даному при виклику внутрішньої функції вона доступається до змінної `v3` та аргументу `v2`, які мали область видимості тільки в `messageBuilder` й на момент виклику мали б бути знищені, однак при створенні внутрішньої функції дані змінні приєднались до області видимості анонімної функції, тобто "замкнулись" разом з нею.