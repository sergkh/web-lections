---
marp: true
theme: gaia
_class: lead
paginate: true
backgroundColor: #fff
backgroundImage: url('https://marp.app/assets/hero-background.svg')

---

<style>
img[alt~="center"] {
  display: block;
  margin: 0 auto;
}
</style>

Авторизація та аутентифікація
======

----

Методи автентифікації користувача
------

Протокол HTTP не зберігає стану між запитами. Це є як його перевагою (серверу не потрібно відслідковувати стан, тому він може потребувати менше ресурсів) так і недоліком, тому що залишається відкритою проблема ідентифікації користувача. 

Потрібен механізм, який допоміг би зв’язати різні HTTP запити й сказати що вони відносяться до однієї сесії роботи користувача. Наприклад, в інтернет магазині потрібно знати що запит замовлення товару відправив той самий користувач, який 5 хвилин назад додав мікрохвильову піч у корзину, а не інший який просто натиснув кнопку замовлення. 

----

Варіант просто завести відповідну змінну "корзина" на сервері буде прекрасно працювати під час розробки - оскільки тільки ви, як розробник, будете замовляти товари. Однак, як тільки користувачів стане більше – вони працюватимуть паралельно, можливі різні варіанти, коли один користувач буде замовляти товари іншого і перетирати чужі замовлення. Тому такий підхід краще відкинути одразу.

---

Перше, що спадає на думку – визначати користувача по IP адресі, однак відношення між користувачем та IP не є одним до одного - можливий варіант коли багато користувачів працюють під однією IP адресою (NAT, Proxy), або ж навпаки один користувач може мати динамічну IP адресу, яка буде змінюватись під час перегляду сторінок сайту. Тому цей варіант не підходить. 

---

Однак можна виділити такі підходи:

1. Додавати параметр в кожен URL та в форми.
2. Додавати певний параметр до кожного HTTP пакету

Перший варіант досить очевидний, хоч і не зручний — при першому заході користувача, або ж після логіну додавати до всіх URL на сайті певний параметр — ідентифікатор сесії, який можна зв’язати з користувачем. 
Звʼязування може бути в памʼяті сервера, або ж в базі даних, де буде зберігатись ідентифікатор сесії та користувач, якому він належить, а також час життя сесії.

---

При цьому ідентифікатор сесії має бути достатньо великим й випадковим, тому що, якщо взяти, наприклад, просто номер сесії підряд чи логін/ідентифікатор користувача:

	http://secure.somesite.com/userspage?sessionId=1567

зловмиснику досить просто буде підібрати ідентифікатор просто перебираючи номери чи логіни підряд, або ж хитріше - отримавши ідентифікатор своєї сесії додати чи відняти від нього 1 - отримаєш сесію попереднього або наступного користувача. 

---

Тому ідентифікатором сесії обирають достатньо довгий та випадковий набір символів, який не пов’язаний з користувачем:

	http://secure.somesite.com/userspage?sessionId=903hfw74n6lMsEfyodG8rWebk4p248v

Це не дуже зручно ні для користувача ні для розробників, оскільки потрібно не забути всюди додати параметр сесії в URL або ж як параметр форм. Також він має суттєвий недолік — користувач може випадково передати доступ до свого акаунта передавши URL на сайт комусь із знайомих. Тому зазвичай для ідентифікації користувача використовуються другий варіант, який реалізується за допомогою *Cookies*, і тільки якщо вони вимкнені в браузері, прибігають до першого варіанту.

---

# Робота з *Cookies*

*Cookie* - це фрагмент даних, який встановлюється веб-сервером (зрідка на клієнтській стороні) і зберігається браузером на компʼютері користувача. Браузер при доступі до сайту додає цей фрагмент даних до кожного HTTP пакету. При цьому особливістю *Cookie* є те, що вони передаються тільки при доступі до того домену, для якого вони були встановлені, тобто *Cookie* встановлена сайтом *facebook.com* буде передаватись тільки при доступі до сторінок цього сайту й ніякого іншого. 

---

*Cookie* дозволяють зберігати дані між запитами на стороні користувача, й на практиці зазвичай використовуються для:

1. Аутентифікації користувача;
2. Зберігання персональних переваг і налаштувань користувача;
3. Відстеження сеансу користувача;
4. Ведення статистики по користувачам.

---
# Принцип роботи

*Cookie* складаються з назви прараметру та значення, й таких *Cookie* може бути скільки завгодно. Для того, щоб встановити *Cookie* сервер передає браузеру спеціальний заголовок HTTP пакету:

`Set-Cookie: name=value; expires=date; path=/; domain=.example.org.`

Після чого браузер в кожному наступному запиті буде передавати отримані дані також у заголовку:

`Cookie: name=value`

---

Розповсюджений сценарій використання — створення *Cookie* з даними користувача та його сесії взаємодії з сайтом після логіну. Таким чином стає можлива ідентифікація всіх наступних дій користувача за допомогою цієї *Cookie*. 

При натисненні кнопки "Вихід" або ж по проходженню певного періода чи закритті вікна браузера — *Cookie* знищується. Однак досить багато сайтів створюють *Cookie* одразу при заході на сайт й таким чином можуть запам’ятовувати налаштування користувача чи ідентифікувати його у майбутньому. 

---
# Встановлення *Cookie* в express.js

```javascript


app.get('/login', (req, res) => {
  ...
  if (loggedIn) {
    res.cookie('session', "fsdakjhfklj23hih21u9rhewjkfhkjsfhsdakjfask", {
      maxAge: 900000, // час життя в мілісекундах
      httpOnly: true, // доступ тільки з сервера
      secure: true // передавати тільки по https
    })		
    res.redirect('/');
  }
});
```

---

# Зберігання даних користувача

В кукі не зберігають критичні дані користувача, а тільки ідентифікатор сесії, який потім можна використовувати для отримання даних користувача з бази даних. Оскільки:

1. Розмір *Cookie* обмежений (максимум 4093 байт);
2. *Cookie* передаються з кожним запитом, що збільшує трафік між клієнтом та сервером;
3. *Cookie* можуть бути легко підроблені на клієнті.

---

Тому в *Cookie* зберігають тільки ідентифікатор сесії, а всі інші дані користувача зберігаються на сервері, наприклад в памʼяті:

```javascript
import crypto from 'crypto';
let sessions = new Map();
...
let sessionId = crypto.randomBytes(32).toString('hex');
sessions.set(sessionId, {
  userId: user.id,
  userName: user.name,
  settings: { theme: 'dark' }
});

res.cookie('session', sessionId, {maxAge: 900000, httpOnly: true, secure: true});
```

Однак при перезавантаженні сервера всі сесії будуть втрачені, тому краще зберігати їх в БД/Redis/Memcached.

---

# Атрибути *Cookie*

Обов’язковими для *Cookie* є пара name=value, однак розглянемо інші можливі атрибути:

	Set-Cookie: lang=ua; expires=Fri, 31 Dec 2013 10:59:59 GMT; path=/; domain=.mydomain.net; Secure; HttpOnly; 

`Expires` : вказує час, після якого *Cookie* буде автоматично видалено. Якщо цей атрибут не вказаний, то *Cookie* зберігається до закриття браузера.

`Max-Age`: другий варіант вказання часу життя *Cookie* - час в секундах скільки буде дійсна *Cookie*.

---

`Domain`: домен, для якого *Cookie* є дійсним. Доступ до *Cookie* завжди обмежений доменом з якого він був встановлений, що є основою безпеки для *Cookie*, й якщо не вказати цього явно - буде використаний домен сайту який встановлював *Cookie*. Явно вказувати домен необхідно, якщо потрібно дозволити доступ до *Cookie* з піддоменів. Завжди починається з крапки.

`Path`: визначає частину URL, для яких видима *Cookie*.

`Secure`: наказує передавати *Cookie* тільки по безпечному з’єднанню – https.

`HttpOnly`: вказує, що значення *Cookie* неможливо отримати з javascript через об’єкт document.cookie.

`Version=1`: - версія.

---

# Приклад читання *Cookie*

Скористаємось бібліотекою *cookie-parser*: `npm install cookie-parser`

```javascript
import cookieParser from 'cookie-parser';
app.get('/profile', (req, res) => {
  const sessionId = req.cookies.session;
  const session = sessions.get(sessionId);

  if (session) {
    res.send(`Welcome ${session.userName}`);
  } else {
    res.status(401).send('Unauthorized');
  }
});	
```

---

Переглянути всі *Cookie*, які зберігає браузер зазвичай можна в консолі розробника:

![width:800px center](https://github.com/sergkh/vntu-web-mblog/raw/lections/img/cookies-browser-view.png)


---
До недоліків *Cookie* можна віднести:
* дані постійно передаються з кожним запитом, що збільшує трафік між клієнтом та сервером й значно обмежує обсяги даних, які можна зберігати в *Cookie*. 
* критичні дані можуть бути прочитані й підроблені. Якщо зловмисник отримає доступ до комп’ютера користувача (або ж доступ до трафіку) він може легко скопіювати значення *Cookie* й підставити його в свої запити. 

Щоб боротись з останнім недоліком *Сookie* часто шифруються або підписуються закритим ключем й значно обмежуються в терміні дії (іноді до 15-20 хвилин).

---

# Підписані *Cookie*

Підписані *Cookie* - це *Cookie*, які містять підписані дані, що дозволяє серверу перевірити, що дані не були змінені на стороні клієнта.

---

# Сессія користувача

Все перелічене вище реалізовано в бібліотеках, таких як *express-session* для *Node.js* або ж passport.js.

Розглянемо роботу з *express-session*:

```bash
npm install express-session
```

---

Після чого в коді сервера необхідно підключити бібліотеку та додати її в стек обробки запитів:

```javascript
import express from 'express';
import session from 'express-session';

const app = express();

app.use(session({ secret: 'secret-key', resave: false, saveUninitialized: false}));
```

---

# Використання

```javascript
app.get('/login', (req, res) => {
  if (loggedIn) {
    req.session.userId = user.id;
    res.redirect('/');
  }
});

app.get('/profile', (req, res) => {
  if (req.session.userId) {
    res.send(`Вітаємо ${req.session.userId}`);
  } else {
    res.status(401).send('Unauthorized');
  }
});
```

---

До недоліку сессій варто віднести те, що до використання сесій сервер фактично не мав ніякого стану: всі дані, які користувачі вносили одразу зберігались в базу даних, а всі які читались брались з БД. 

Така архітектура дозволяла легко підключати скільки завгодно таких серверів до СУБД й розподіляти навантаження між ними будь-яким чином, оскільки кожен запит на кожному з серверів виконувався б однаково. З використанням сесій ця перевага втрачається — якщо користувач залогіниться на одному з серверів, його сесія буде створена тільки на цьому сервері. Також при перезавантаженні всі сесії користувачів будуть втрачені й їм доведеться логінитись знову.

---

Існують наступні вирішення перелічених проблем:
 - Можливо налаштувати зберігання сесій на диск при перезавантаженні.
 - Деякі сервери вміють періодично обмінюватись даними сесій між собою.
 - При балансуванні можна прив’язувати всі запити з однієї IP адреси до одного з серверів.
 - Можна обмежитись використанням тільки підписаних *Cookie*, 
 - Можна зберігати дані сесії в СУБД/Redis/Memcached
