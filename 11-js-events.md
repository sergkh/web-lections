Обробка подій в Javascript
--------

Більшість дій, які програмуються за допомогою JavaScript у веб додатках, це обробка різноманітних подій від користувача та браузера. Події можуть генеруватись елементами 

DOM -події, які ініціюються елементами DOM . Наприклад , подія click відбувається при кліці на елементі , а подія mouseover - коли покажчик миші з'являється над елементом ,
Події вікна . Наприклад подія resize - при зміні розміру вікна браузера ,
Інші події , наприклад load , readystatechange . Вони використовуються , скажімо , в технології AJAX.
Саме DOM- події пов'язують дії , що відбуваються в документі , з кодом JavaScript , тим самим забезпечуючи динамічний веб -інтерфейс.

Події можна додавати через атрибути елементів. Розглянемо приклад додавання функцій для валідації форми:

	<html>
	<body>
		<form id="order-form" action="/order" method="POST" onsubmit="return validate(this);"> 
			Email:
			<input type="text" name="email" onchange="emailCheck(this)">
			How many apples?
			<input type="text" name="quantity" onchange="rangeCheck(this, 1, 100)">
			<input type="submit" value="Order"/>
		</form>
	</body>

	<script type="text/javascript">
		function emailCheck(elem) {
			var text = elem.value;
			var regEx = /[a-zA-Z][\w\.]*@[\w\.]{2,}/;

			if(!regEx.test(text)) {
				alert("Email is not valid");
				return false;
			}

			return true;
		}

		function rangeCheck(elem, min, max) {
			var v = parseInt(elem.value);

			if(isNaN(v)) {
				alert(elem.name + " is not a number");
				return false;
			}

		   	if (v < min) {
		      alert(elem.name + " has to be greater than " + min);
		      return false;
		   	}

		   if (v > max) {
		      alert(elem.name + " has to be less than " + max);
		      return false;
		   }

		   return true;
		}

		function validate(formEl) {
		   return emailCheck(formEl.email) & rangeCheck(formEl.quantity, 1, 200);
		}

	</script>
	</html>

Додавання подій з Javascript
----

Можливо також додавати події до елементів безпосередньо з javascript. Для цього необхідно знайти елемент до якого необхідно додати обробник та встановити його:

	var formElem = document.getElementById("order-form"); // знаходимо форму за ідентифікатором

	formElem.onsubmit = function() { 
		return emailCheck(formEl.email) & rangeCheck(formEl.quantity, 1, 200); 
	};

`document` це об’єкт браузера, що представляє собою об’єктну модель HTML-документу (DOM - Document Object Model), тобто містить об’єкти всіх тегів, що знаходяться на сторінці, їх атрибутів, вмісту і т.д. Роботу з DOM більш детально буде розглянуто далі.

В даного коді не врахована одна особливість роботи браузера - javascript код виконується по мірі завантаження сторінки, не очікуючи завантаження інших елементів. Тобто якщо документ буде мати наступну структуру:


	<script> попередній скрипт </script>

	...

	<form id="order-form"> форма </form>

То можлива ситуація, що браузер почав виконувати скрипт, ще не отримавши елемент `form` від серверу, тоді код `document.getElementById("order-form")` не знайде необхідного елементу. Найбільш правильним підходом буде помістити даний код у функцію, що викликатиметься, коли весь документ буде завантажено. Така подія є у елементу `<body>`:

	<body onload="documentReady()">

Тепер помістивши код у функцію `documentReady()`:

	function documentReady() {
		/// попередній код
	}

Після чого код відпрацьовуватиме вірно.

Список найбільш використовуваних подій
--------

Для всього документу:

`onload`
: викликається коли браузер завантажив усі елементи документу.

		<body onload="documentLoaded()">

	Javascript варіант:

		window.onbeforeunload=function(){ ... };


`onbeforeunload`
: викликається перед закриттям вікна, може не працювати по різному в різних браузерах:
	
		<body onbeforeunload="return confirm('O RLY?');">

`onresize`
: Викликається коли розмір вікна браузера змінився:

		<body onresize="alert('Size changed')">


Для елементів:

`onclick`
: клік на елементі

		<div onclick="divClicked(this)">

`ondblclick`
: подвійний клік на елементі

`onmouseover`
: переміщення мишки над елементом

`onkeydown`
: натиснення клавіші клавіатури


Для форм:

`onblur`
: при втраті фокусу введення з елементу

		<input type="text" onblur="validateValue()">	

`onchange`
: при втраті фокусу введення з елементу, якщо значення його змінилось 

`onfocus`
: при отриманні фокусу введення

`onsubmit`
: при відправці форми

		<form onsubmit="return validateForm(this);">


Робота з DOM
----------

DOM (англ. Document Object Model - Об'єктна модель документа) — програмний інтерфейс для роботи зі структурованими документами. Використовується DOM, як правило, для XML-подібних документів, куди входить і HTML, однак поширений й для інших видів документів, так багато бібліотек для роботи з word/excel файлами теж реалізують DOM.

DOM бібліотеки після розбору документу будують дерево об’єктів, де коренем є сам документ, у якого зазвичай є один піделемент - кореневий елемент документу, й у нього є список дочірніх піделементів, які вже представляють HTML-теги сторінки, у кожного піделементу також є список дочірніх елементів. У кожного з елементів DOM визначено набір методів та атрибутів, які дозволяють керувати цим елементом - змінювати атрибути тегу, вміст чи навіть переносити елемент по дереву. 

> Ще одним поширеним підходом до роботи зі структурованими документами є SAX - підхід, при якому документ представляється як потік даних - аналізатор послідовно розбираючи документ генерує повідомлення, які містять елементи документу, які він розібрав. Зазвичай такі парсери менш зручні у використанні, однак при правильній реалізації потребують значно менше пам’яті.

В javascript браузер будує й оновлює DOM-дерево автоматично, тому змінюючи DOM-елемент з javascript, наприклад змінюючи значення атрибуту `width` - браузер одразу відобразить зміни на сторінці - змінить довжину елементу. Представлено DOM-дерево поточного документу через передвизначений об’єкт `document`. У нього зазвичай використовують 2 піделементи: `document.documentElement` - який відповідає кореню документу, тобто тегу `<html>` та `document.body`, що відповідає тегу `<body>`. 

Кожен елемент має посилання на масив дочірніх елементів:

        var childNodes = document.body.children;
 
        for(var i = 0; i < childNodes.length; i++) {
            alert(childNodes[i])
        }

У кожного з елементів масив `childNodes[i]` є список його дочірніх елементів й так далі. Однак шукати елемент таким чином не дуже зручно, тому існують додаткові функції пошуку елементу в дереві:

	var planets = document.getElementById('planets');
	var firstSpan = planets.getElementsByTagName('span')[0];
	var elements = document.querySelectorAll('#planets>span');

Перший вираз знайде елемент за ідентифікатором, `firstSpan` буде відповідати першому тегу `<span>` всередині тегу `planets` (однак кине виключення, якщо жодного тегу `<span>` не всередині `planets` не буде знайдено). Третій варіант демонструє пошук елементу за CSS селектором.

Коли елемент, який необхідно змінити знайдено, можливо над ним виконувати певні дії, наприклад нехай є HTML код:

	<div id="error-text">old text</div>

Можна переглянути та змінити вміст елементу:

	var errorDiv = document.getElementById('error-text');
	alert(errorDiv.innerHTML ); // покаже 'old text'
	errorDiv.innerHTML = 'OK';  // змінить вміст на 'OK'

Можливо доступатись не тільки до вмісту тегу, а й його атрибутів:

`element.hasAttribute(name)`
: повертає true, якщо у елементу встановлено атрибут з іменем `name`:

		var hasId = errorDiv.hasAttribute('id'); // = true

`element.getAttribute(name)`
: повертає значення атрибуту, якщо встановлено, у вигляді тексту.

		var id = errorDiv.getAttribute('id'); // 'error-text'

`element.setAttribute(name, value)`
: встановлює нове значення `value` атрибуту з іменем `name`. Встановимо клас `success` знайденому елементу:
	
		errorDiv.setArribute('class', 'success');

`element.removeAttribute(name)`
: видаляє атрибут з іменем `name`. Щоб видалити атрибут `class`:

		errorDiv.removeArribute('class');

Для деяких атрибутів існують скорочення, наприклад для тегів `<input>`:

	input.value == input.getAttribute('value'); // значення елементу вводу
	input.checked == input.getAttribute('checked'); // значення чекбоксу

Для того щоб додати елемент в документ, необхідно його створити, для чого є відповідний метод у документа:

	var li = document.createElement('li');
	li.innerHtml = 'Новий елемент';
	document.getElementById('items-list').appendChild(li);

Також додаткові функції для додавання елементів:

`elem.cloneNode(deepCopy)`
: клонує елемент, якщо `deepCopy=true`, то клонуються також всі піделементи даного, якщо ж `deepCopy=false`, то клонується тільки даний елемент без дочірніх.

`parentElem.appendChild(elem)`
: додає елемент `elem` до `parentElem`.

`parentElem.insertBefore(elem, nextSibling)`
: додає елемент `elem` до `parentElem` перед елементом `nextSibling`.

`parentElem.removeChild(elem)`
: видаляє елемент `elem` з батьківського `parentElem`.

`parentElem.replaceChild(elem, currentElem)`
: заміняє елемент `currentElem` елементом `elem` у батьківському елементі `parentElem`.

Бібліотека jQuery
--------

Бібліотека jQuery, це популярна відкрита бібліотека, що дозволяє значно спростити маніпуляції з DOM деревом в Javascript й надає широкі можливості по обробці подій від елементів, створення AJAX запитів та багато іншого.

Для того, щоб підключити бібліотеку, необхідно [скачати бібліотеку](http://jquery.com/download/) та додати файл бібліотеки до HTML документу:

	<script type="text/javascript" src="/js/jquery.js"></script>

Або ж її можна підключити через Google або ж іншу мережу [CDN](http://ru.wikipedia.org/wiki/Content_Delivery_Network):

	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>

> Google та деякі інші сайти зберігають на своїх серверах широковживані бібліотеки й дозволяють підключати їх у свої додатках такі сховища називають CDN. З переваг ви отримаєте - менше на один запит до вашого серверу та швидшу роботу сайту, оскільки по-перше для завантаження буде обрано сервер який географічно близький до користовувача й може бути ближчим за ваш, а по-друге, якщо користувач вже заходив на інший сайт де завантажувалась ця ж бібліотека, то вона може бути закешованою браузером.

Підключення скрипта без вказання протоколу `src="//..."` вказує що необхідно використати протокол, по якому була віддана сторінка - для http сторінок буде використано URL `src="http://..."`, а для https - `src="https://..."`. Однак якщо ви будете вікривати html файл з локальної файлової системи, а не з сервера - буде підставлено протокол `src="file://..."` й відповідно скрипт знайдено не буде.

Бібліотека jQuery значно простіша у використанні та надає набагато більше можливостей для роботи з DOM ніж чистий Javascript. Розглянемо основні можливості бібліотеки.

> Найкраще jQuery описана в книзі Эрла Каслдайна та Крейга Шаркі - "JQuery Novice to Ninja" або ж на російській у [Антона Шевчука](http://anton.shevchuk.name/jquery-book/). Сайт офіційної [документації](http://api.jquery.com/).

Після підключення бібліотеки з’являється глобальна функція (клас) `jQuery` яка також має скорочене ім’я `$`. Дана функція приймає один аргумент - CSS селектор, за який необхідно вибрати елемент чи елементи над якими відбуватимуться маніпуляції:

	var elems = $('.dyn');

В результаті даного коду змінна `elems` буде містити список елементів які мають клас `dyn` загорнуті у об’єкт jQuery. Далі з ними використовуючи функції jQuery можна проводити різні маніпуляції:

	elems.html('Новий вміст'); // Змінити вміст елементів на вказаний
	elems.show(); // показати вказані елементи, якщо раніше вони були приховані

Специфіка jQuery така, що кожен метод (окрім методів отримання даних з елементу) повертає цей самий об’єкт, тому можна використовувати ланцюжки з викликів фукнцій (chain calls). Коротший запис вказаного буде виглядати:

	$('.dyn').html('Новий вміст').show();

Такі ланцюги можуть бути скільки завгодно довгими, а якщо жодного елементу з класом `dyn` не буде знайдено, то не буде створено виключення, а просто дані функції будуть викликані для пустого масиву й відповідно не дадуть ніякого ефекту. Роглянемо ще можливі функції для модифікації елементів:

	$('#err-msg') 				// 	знаходимо елемент за ідентифікатором err-msg
		.addClass('warning')    //  додає клас warning, всі класи, які були до цього залишаються
		.css('color', 'red')	//	додає CSS властивість до елементу color: red
		.attr('width', '15px')	//  додає або змінює атрибут width елементу на значення 15px
		.fadeIn(500);			//  аналогічний до show(), однак елемент з’являється поступово протягом 500 мс

Для даних функцій є також зворотні функції:

	$('#err-msg') 				
		.removeClass('warning') //  видаляє клас warning, всі класи, які були до цього залишаються
		.css('color', 'green')	//	CSS властивість не можна видаляти, можливо тільки змінити
		.removeAttr('width')	//  видяляє атрибут width, якщо він був
		.fadeOut(500);			//  поступово приховує елемент протягом 500 мс. (аналогічний метод - hide())

Можливо також не тільки змінювати властивості, а й просто отримувати їх значення. Зазвичай такі функції називаються аналогічно до функцій встановлення значення однак мають на один аргумент менше:

	$('el').html('Value');		// встановлює новий вміст елементу
	var content = $('el').html()	// отримує вміст елементу

	$('el').text('Value'); 		// встановлює вміст елементу як текст (аналогічний методу html, однак розрахований на текст)
	var content = $('el').text()	// отримує текстовий вміст елементу

	$('a#required').attr('href', 'http://ya.ru');		// змінює посилання
	var loc = $('a#required').attr('href');			// отримує значення отрибуту 'href' у посилання

Також за допомогою jQuery можна додавати обробники подій на елементи. Для цього використовується знайомий вже селектор для вибору елементів до яких нобхідно додати обробник, та функція [.on()](http://api.jquery.com/on/) яка приймає назву події та функцію обробник, при цьому в функції `this` вказує на DOM елемент у якого виникла подія. Наприклад додамо підтвердження для всіх посилань, що мають клас confirmable

	$('a.confirmable').on('click', function(e) {
		var link = $(this).attr('href'); // для того щоб отримати всі переваги jQuery DOM-елемент обгортається ф-цією $()
		if(!confirm('Ви дійсно бажаєте перейти на сайт: ' + link)) {
			e.preventDefault();
		}
	});

Функція обробки приймає об’єкт події, який містить інформацію про елемент з яким сталась подія, час події та іншу корисну інформацію, а також метод `preventDefault()` який зупиняє поширення події - тобто посилання не буде спрацьовувати. Більше прикладів можна знайти в офіційній документації.

Додавання елементів схоже на додавання елементів без використання бібліотеки, наприклад нехає є HTML код:

	<ol id="list">
	  <li id="saturn">Saturn</li>
	  <li id="uranus">Uranus</li>
	</ol>

Додати елемент до списку:

	$('#list').append('<li id="mars">Mars</li>');

Можливо додати елемент на вказану позицію:

	$("#list>#saturn").before("<li id="venus">Venus</li>");
	$("#list>#venus").after("<li id="earth">Earth</li>");

Венеру буде додано перед Сатурном, а Землю після Венери.
Результат матиме вигляд:

	<ol id="list">
	  <li id="venus">Venus</li>
	  <li id="earth">Earth</li>
	  <li id="saturn">Saturn</li>
	  <li id="uranus">Uranus</li>
	  <li id="mars">Mars</li>
	</ol>

