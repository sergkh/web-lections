---
marp: true
theme: gaia
_class: lead
paginate: true
backgroundColor: #fff
backgroundImage: url('https://marp.app/assets/hero-background.svg')

---

# SQL

---

Важливою частиною веб додатків є інформація, яку вони надають своїм користувачам. Унікальність й способи подачі інформації часто визначають популярність того чи іншого ресурсу. 

Й відповідно більшість сучасних веб додатків обробляють значні обсяги даних. Важливо розсудливо підійти до вибору способу зберігання даних додатку, тому найчастіше для цього використовуються системи керування базами даних СКБД.

---

Реляційні СКБД дозволяють обробляти великі обсяги даних (мільйони записів) й мають стандартизовану мову для роботи з даними за допомогою спеціальної мови — *SQL*.

Сама по собі *SQL* не є мовою програмування, як *C* або *Pascal*, а лише дозволяє формувати інтерактивні запити або виступати в якості інструкцій для керування даними при роботі з СКБД. Стандарт *SQL*, крім того, вміщує функції для визначення зміни, перевірки і захисту даних.

Серед популярних реляційних СКБД є *MySQL*, *PostgreSQL*, *Oracle*, *MS SQL*.

---

# NoSQL

Також часто використовуються нереляційні СКБД, які можуть надавати додаткові можливості за рахунок відмови від деяких обмежень реляційних СКБД. 

Популярними нереляційними СКБД є *MongoDB*, яка дозволяє зберігати дані у форматі JSON та краще масштабується, Cassandra та інші.

--- 

# SQLite

В нашому випадку ми будемо використовувати легку базу *SQLite*, яка є вбудованою реляційною СКБД і не потребує окремого сервера для роботи, а поставляється у вигляді однієї бібліотеки.

Вона не потребує окремого сервера і є ідеальною для невеликих проектів або мобільних додатків, однак вона не підходить для великих проектів з високими навантаженнями.

---

# Підключення до бази даних

Для роботи з базою даних SQLite в Node.js ми будемо використовувати бібліотеку [sqlite3](https://www.npmjs.com/package/sqlite3).

Додамо її до нашого проекту:

```bash
npm install sqlite sqlite3
```

---

# Модулі в Node.js

Щоб полегшити читабельність та організацію коду винесемо роботу з базою даних в окремий модуль. Створимо файл `db.js` в корені нашого проекту, який надаватиме функції для роботи з базою даних:

```javascript

function getUser(login) { ... }
function getItems() { ... }

export { getUser, getItems };
```
export вказує які функції доступні інших модулях

---

# Підключення до бази даних

У файлі `db.js` підключимо бібліотеку sqlite3 та створимо функцію для підключення до бази даних:

```javascript
import sqlite3 from "sqlite3";
import { open } from "sqlite";
import fs from "fs";
```

---

Опишемо функцію ініціалізації БД:

```javascript
async function initDb() {
  const newDB = !fs.existsSync("app.db");

  const db = await open({
    filename: "app.db",
    driver: sqlite3.Database,
  });

  if (newDB) {
    await db.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT, 
        login TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL);
      INSERT INTO users (login, password) VALUES ('admin', 'qweerty');
    `);
    }

  return db;
}
```

---

Тепер можна створити БД та описати функцію для отримання користувача за логіном та паролем:
(Неправильний варіант!)

```javascript
const db = await initDb();

async function getUser(login, password) {
  return await db.get(`SELECT * FROM users WHERE login='${login}' AND password='${password}'`);
}

export { getUser };
```

---
Використання функції (server.js):

```javascript
import { getUser } from './db.js';

app.post('/login', loginValidators, async (req, res) => {
  ... // Валідація даних
  const { username, password } = req.body;  
  const user = await getUser(username, password);
  
  if (!user) {
    return res.render('index', { errors: [{ msg: 'Invalid username or password' }] });
  } else {
    res.send(`Logged in as ${user.login}`);
  }
});
```

---
# SQL ін'єкції

На основі цього варіанту продемонструємо як можна виконати SQL ін'єкцію:

Наприклад, якщо в якості логіну ввести `admin'; --` то, запит не перевірятиме пароль взагалі, а просто поверне дані користувача з логіном `admin`:

```sql
SELECT * FROM users WHERE login='admin'; --' AND password='qweerty'
```

---

# Запобігання SQL ін'єкціям

Для запобігання SQL ін'єкціям потрібно використовувати параметризовані запити, які дозволяють передавати значення окремо від SQL-коду. Це робить неможливим виконання небезпечних SQL-команд.

Наприклад, правильно функція `getUser`, мала б виглядати так:

```javascript
async function getUser(login) { 
  return await db.get(`SELECT * FROM users WHERE login=?`, [login]);
}
```

---

# Додамо відображення даних з бази

```sql
CREATE TABLE IF NOT EXISTS goods (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT UNIQUE NOT NULL,
  description TEXT NOT NULL
);

INSERT INTO goods (name, description) VALUES ('Phone', 'This is a phone');
INSERT INTO goods (name, description) VALUES ('TV', 'This is a TV');
INSERT INTO goods (name, description) VALUES ('Roomba', 'Vacuum cleaner that cleans your house');
```

---

# Отримання даних з бази


Для отримання даних з таблиці `goods` створимо функцію `getGoods` в нашому модулі `db.js`:

```javascript
async function getGoods() {
  return await db.all(`SELECT * FROM goods`);
}
```

й використаємо її в нашому серверному коді:

```javascript
app.get('/goods', async (req, res) => {
  const goods = await getGoods();
  res.render('goods', { items: goods });
})
```

---
# Відображення даних на сторінці
У файлі `goods.ejs` додамо відображення отриманих товарів:

```ejs
<% items.forEach(item => { %>
  <div class="item">
    <h2><%= item.name %></h2>
    <p>Description: <%= item.description %></p>
  </div>
<% }) %>
```

---

# Пошук товарів

Додамо можливість пошуку товарів за назвою. Для цього створимо форму в `goods.ejs`:

```ejs
<form action="/goods" method="get">
  <input type="text" name="search" placeholder="Search for goods">
  <button type="submit">Search  </button>
</form>
```

---

# Й обробимо запит на сервері:

```javascript
app.get('/goods', async (req, res) => {
  const goods = await getGoods(req.query.search);
  res.render('goods', { items: goods });
});
```
# Додамо функцію пошуку в `db.js`:

```javascript
async function getGoods(search) {
  if (search) {
    return await db.all(`SELECT * FROM goods WHERE name LIKE ?`, [`%${search}%`]);
  } else {  
    return await db.all(`SELECT * FROM goods`);
  }
}
```

---

# Ще одна ін'єкція

Якщо ввести в пошук 
`TV' UNION SELECT id, u.login AS name u.password AS description FROM users u WHERE u.login LIKE '`то буде виконано небезпечний запит, який поверне дані користувачів:

Також небезпечною буде ін'єкція, яка видалить таблицю товарів:
`Roomba'; DROP TABLE goods; --`

Тому знову ж ж таки, потрібно використовувати параметризовані запити:

```javascript
  db.all(`SELECT * FROM goods WHERE name LIKE ?`, [`%${search}%`]);
```

---

# Додавання товарів

Додамо можливість додавання товарів до бази даних. Для цього створимо форму в `goods.ejs`:

```ejs
<form action="/goods" method="post">
  <input type="text" name="name" placeholder="Name" required>
  <input type="text" name="description" placeholder="Description" required>
  <button type="submit">Add</button>
</form>
```

---
# Обробка додавання товарів

Додамо обробку POST-запиту на сервері:

```javascript
app.post('/goods', async (req, res) => {
  const { name, description } = req.body;
  await addGood(name, description);
  res.redirect('/goods');
});
```

В db.js додамо функцію для додавання товарів:

```javascript
async function addGood(name, description) {
  await db.run(`INSERT INTO goods (name, description) VALUES (?, ?)`, [name, description]);
}
```

---

# Завантаження файлів

Якщо необхідно додати, наприклад зображення до товару, то можна використовувати бібліотеки [express-fileupload](https://www.npmjs.com/package/express-fileupload) чи [multer](https://www.npmjs.com/package/multer). Додамо `express-fileupload` до нашого проекту:

```bash
npm install express-fileupload
```

Далі в `server.js` підключимо її:

```javascript
import fileUpload from 'express-fileupload';
...
app.use(fileUpload());
```

---

# Форма для завантаження файлів

Оновимо форму для завантаження файлів в `goods.ejs`:

```html
<form action="/goods" method="post" encType="multipart/form-data">
  <input type="text" name="name" placeholder="Name" required>
  <input type="text" name="description" placeholder="Description" required>
  <input type="file" name="image" accept="image/*">
  <button type="submit">Add</button>
</form>
```

---

# Обробка завантаження файлів

Додамо обробку завантаження файлів в `server.js`:

```javascript
import crypto from 'crypto';
...
app.post('/goods', async (req, res) => {
  const { name, description } = req.body;
  
  if (!req.files || Object.keys(req.files).length === 0) return res.status(400).send('No files were uploaded.');
  
  const fileName = crypto.randomUUID();
  await req.files.image.mv(`./public/images/goods/${fileName}.png`)
  console.log(`Adding good: ${name}, ${description}`);
  await addGood(name, description);
  res.redirect('/goods');
});
```