---
marp: true
theme: gaia
_class: lead
paginate: true
backgroundColor: #fff
backgroundImage: url('https://marp.app/assets/hero-background.svg')

---

<style>
img[alt~="center"] {
  display: block;
  margin: 0 auto;
}
*{
    font-size: 0.8em;
}

em { 
	font-size: 0.9em; 
}

small {
    font-size: 0.7em;
}
</style>

Основи роботи Web
=====

---

**JavaScript** — мова написання сценаріїв для веб-сторінок та вбудованих сценаріїв, що базується деяких функціональних концепціях та принципах прототипного наслідування.

*JavaScript* було створено на хвилі популярності мови *Java*, тому компанія *Netscape*, яка власне створювала дану мову, отримала дозвіл від *Sun* додати в назву слово *Java*, але крім назви дані дві мови мають дуже мало спільного - це мови різного призначення, різних можливостей та підходів до створення програм. 

*JavaScript* спочатку створювався як мова для браузерів, однак з часом вона стала використовуватися в багатьох інших сферах, наприклад, в серверних додатках, мобільних додатках, іграх та інше.

---

Початкове застосування *Javascript* в основному було для часткової автоматизації обробки та завантаження даних сторінки, наприклад, перевірка даних, що вводить користувач на льоту, обрахунки, а пізніше умовне завантаження частин сторінки та інше. 

Однак з часом все більше й більше компаній почали впроваджувати RIA (Rich Internet Applications) - веб додатки, що по функціоналу, можливостям та швидкості роботи максимально наближені до звичайних додатків й досягається це в тому числі засобами *Javascript*, тому тенденція така, що доля функціоналу реалізованого на *Javascript* в додатках зростає.

Також *Javascript* використовується в багатьох інших сферах, наприклад, в NodeJs - серверній платформі, що дозволяє створювати серверні додатки. Electron - фреймворк для створення кросплатформних настільних додатків, React Native - фреймворк для створення мобільних додатків, а також в багатьох інших сферах.

---

*Javascript* відрізняється від традиційних об’єктно орієнтованих мов — він не підтримує основні принципи ООП, але при цьому має деякі властивості об’єктно-орієнтованої мови: в ньому є об’єкти, прототипне наслідування та поліморфізм. 

Також підтримуються деякі властивості функціональних мов програмування: функції як об’єкти першого рівня, об’єкти як списки, currying, анонімні функції, замикання (closures).

JavaScript має *C*-подібний синтаксис, який дещо схожий на спрощений синтаксис мови *Java*. Семантика мови схожа з семантикою *Self*.

---

Вбудовування в *HTML*
----------

Текст javascript програми включається безпосередньо в *HTML*-документ і виконується вбудованим в браузер *Javascript* двигуном (engine). Абсолютна більшість сучасних браузерів підтримують *Javascript*. 

##### Використовуючи теги `<script>`

Код *JavaScript* вставляється в теги `<script></script>` з обов’язковим атрибутом `type="text/javascript"`. Традиційний Hello, World! можна описати наступним чином:

```html
<script type="text/javascript">
  alert('Hello, World!');
</script>
```

В данному випадку показується діалогове вікно з повідомленням. Код *Javascript* виконується браузером одразу по мірі його зустрічання на сторінці.

---

##### Підключення зовнішніх файлів

Другим варіантом підключення *Javascript*, по аналогії з *CSS* — використання окремих файлів, та підключення їх до сторінки:

```html
<script type="text/javascript" src="/js/registration.js"></script>
```

---

##### Вбудовування в *HTML* через атрибути

Ну й знову ж таки по аналогії з *CSS* - можливо включати *Javascript* безпосередньо в атрибути тегів. Наприклад наступний код покаже діалогове вікно при натисканні на посилання та перейде на нього тільки якщо користувач натиснув так:
 
```html
<a href="http://anothersite.com" onclick="return confirm('Ви дісно хочете перейти на інший сайт?');">Посилання</a>
```

Працює це наступним чином - функція `confirm()` покаже діалогове вікно з написом та в залежності від того, що натиснув користувач поверне `true` або `false`. А конструкція `return false;` в обробнику `onclick` тега заблокує перехід за посиланням. 

---

## Підхід прогресивного збагачення документу

Код *Javascript* при цьому буде працювати тільки, якщо він підтримується й увімкнений в браузері, в останньому випадку — нічого страшного не відбудеться якщо *Javascript* буде вимкнено — просто перехід за посиланням відбуватиметься без підтвердження. 

Тобто *Javascript* допомагає користувачу, однак без нього сайт теж працюватиме нормально — такий підхід був популярний кілька років тому, однак зараз відходить на другий план — все більше й більше додатків не зможуть як слід працювати без підтримки *Javascript*. 

Такий підхід називається *прогресивне збагачення* (progressive enhancement) — спочатку створюється базовий функціонал, який працює без *Javascript*, а потім додається додатковий функціонал, який працює тільки при підтримці *Javascript*.

---

Для того, щоб відобразити користувачу повідомлення, якщо у нього вимкнено або відключено javascript (як і будь-які клієнтські скрипти) існує спеціальний тег `<noscript>`:

```html
<body>
  <noscript>Вибачте, але у вас не підтримується javascript, який так необхідний для нашого сайту</noscript>
</body>
```

---

Типи даних
---------

В *Javascript* є всього 6 основних типів даних:

boolean: булеві значення - `true` або `false`

```javascript
let flag = false;
```

number: числа як цілі так і дробові

```javascript
const num = 5.0;
```

Як видно перед визначенням змінної не вказується тип, оскільки *Javascript* є динамічно типізованою мовою, тобто тип змінної визначається автоматично при присвоєнні значення. Однак необхідно вказати одне з ключових слів `let` (змінна, або старіший варіант `var`) або `const` – константа.

---

string: стрічки. Визначається в подвійних або в одинарних лапках (рівнозначно):

```javascript
let str = "Деяка стрічка";
let strWithHtml = '<a href="http://apple.com">До яблук</a>';
```

Також в *Javascript* підтримуються шаблонні стрічки, які обмежуються зворотними лапками (backticks). Вони дозволяють вставляти змінні та вирази в стрічку за допомогою `${}`:

```javascript
let strWithBackticks = `Це стрічка з ${num} числом`;
let backticksWithHtml = ```
Багаторядкова стрічка
```;
```

Крапка з комою в кінці рядка не є обов’язковою, однак рекомендується її використовувати.

---

array: массиви даних
```javascript
let arr = [];
let arr2 = [1, 2, 3, "текст", true];
```

object: об’екти

```javascript
let obj = {};
obj.name = "Дмитро";
obj.age = 30;
obj["city"] = "Київ";

let obj2 = {
  name: "Кіндрат",
  age: 30,
  city: "Київ"
};
```

---

function: функції

```javascript
function add(a, b) {
  return a + b;
}

let sum = add;

let pow = function(x, n) {
  return x ** n;
}

let pow2 = (x, n) => x ** n; // стрілочна функція
```

*Javascript* є динамічно типізованою мовою, тому тип аргументів визначається автоматично при виклику функції, тому фукнція `add` може приймати як числа, так і стрічки, в залежності від того, що передали в неї при виклику.

---

Функції можуть повертати значення, при цьому якщо функція не повертає значення, то вона повертає `undefined`. 

```javascript
function greet(name) {
  if (name) {
    return `Привіт, ${name}!`;
  }
}
```

Також можна створювати функції всередині інших функцій, такі функції називаються *вкладеними* (nested) або *внутрішніми* (inner) функціями:

```javascript
function buildHandler() {
  return function handler() {
    console.log("Це внутрішня функція");
  }	
}

build()(); // викликаємо зовнішню функцію, яка повертає внутрішню
```

---

# Аргументи функцій

Javascript функції можуть приймати необмежену кількість аргументів, при цьому якщо аргументів передали менше ніж вказано в сигнатурі функції, то відсутні аргументи будуть мати значення `undefined`. Якщо ж аргументів передали більше, то вони будуть проігноровані.

```javascript
function add(a, b) {
  return a + b;
}

console.log(add(1, 2, 3));
console.log(add(1));
```

---

# Typescript

Існує окрема мова *Typescript*, яка є надбудовою над *Javascript* та дозволяє використовувати статичну типізацію, тобто вказувати типи змінних, аргументів функцій та повертаємого значення функцій. Це дозволяє зменшити кількість помилок в коді та зробити його більш читабельним.

```typescript
let x: number = 10
const y: string = "Hello"

function add(a: number, b: number): number {
  return a + b;
}

```

---

Особливо це корисно в великих проектах з багатьма розробниками та просто при розробці складних додатків, де важливо мати чітке розуміння типів даних, які використовуються в коді. В javascript не зрозуміло які поля є у користувача:

```javascript
let user = fetchUserData('/user');
```

У випадку з *Typescript* можна вказати тип даних, який повертає функція `fetchUserData`, що дозволяє отримати переваги статичної типізації:

```typescript
let user: {
  name: string;
  age: number;
};

let user: User = fetchUserData('/user');
```

Однак *Typescript* не підтримується в браузерах, тому для його використання доведеться всі файли перетворити в javascript спеціальною програмою – транспіллером.

---
   
Будь яке значення в *Javascript* може бути автоматично перетворене на об’єкт, тому іноді кажуть що в *Javascript* все є об’єктом, хоча насправді це не так, наприклад, якщо розглянути typeof для стрічки та об’єкту String:

	alert(typeof "test");
	alert(typeof new String("test"));

Перший видасть `string`, а другий `object`.

Також автоматичне перетворення в *Javascript* застосовується і для порівняння змінних, так `(1 == "1")` поверне результат `true`, оскільки стрічка буде автоматично перетворена на число. Дякуючи цьому в мову введено два оператори порівняння == та === (й відповідно зворотніх != та !==), оператор з приведенням типів та без приведення. Розглянемо коли таке може бути корисним:

	'' == '0'           // false
	0 == ''             // true
	0 == '0'            // true

	true == 1			// true
	false == 'false'    // false
	false == '0'        // true

	false == undefined  // false
	false == null       // false
	null == undefined   // true

	' \t\r\n ' == 0     // true

Однак для `===`:

	'' === '0'          // false
	0 === ''			// false
	0 === '0'           // false

	false === '0'       // true
	null === undefined  // false
	' \t\r\n ' === 0     // false

> Оператори `==` та `!=` часто називають evil twins, оскільки вони досить часто призводять до неочікуваних результатів, тому як загальна рекомендація - в більшості випадків використовувати оператори `===` та `!==`

Як можна було помітити, змінні об’являються за допомогою ключового слова `var`, однак змінну можливо об’явити й без нього, тоді така змінна автоматично стає глобальною: 

	globalVar = 42;

В браузері всі глобальні змінні прив’язуються до об’єкту ’window’ (в *NodeJs* — глобальний об’єкт називається `global`), тому це автоматично еквівалентно запису:

	window.globalVar = 42;

Дана властивість може привести до неочікуваних проблем:

	function writeNTimes(v, n) {
  	  for( i = 0; i < n; i++ ) {  
            document.write(outTimes + ' ');
  	  }
	}
 
	for( i = 0; i < 3; i++) {
	  document.write('Values ' +  i + ' : ');
	  writeNTimes(i, 4);
	}

В результаті зовнішній цикл відпрацює тільки одну ітерацію, оскільки змінна `i` глобальна й відповідно це та сама зміна, що й функції. Результатом буде:

	Values 0: 0000

В javascript визначено деякі стандартні значення:

`NaN`
: значення, що зазвичай отримується в результаті арифметичних операцій та означає що результатом є не число. Наприклад, метод `parseInt` що перетворює стрічку в число у випадку якщо стрічка не є числом повертає `NaN`. Це значення в Javascript не дорівнює нічому, тому перевіряти на `NaN` необхідно через спеціальну функцію `isNaN()`: 

 		var n = parseInt("word")
 		alert(isNaN(n));

`null`
: пусте значення.

		var n = null;

`undefined`
: значення, яке вказує що змінна (чи поле об’єкту) не існує. Зазвичай це значення використовується у операторах перевірки, при цьому необхідно застосовувати оператор `===`, створимо глобальну змінну тільки якщо її не існує:

		if( undefined === window.clickCounter ) {
		  window.clickCounter = 1;
		}

Infinity
: безкінечність, можна отримати наприклад в результаті операції `1/0`. Буває позитивною та негативною. Краще за все перевіряти чи число дорівнює безкінечності використовуючи функцію `isFinite`, яка поверне true, якщо число не є NaN і є кінечним.

