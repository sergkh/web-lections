AJAX
---------

AJAX (Asynchronous JavaScript And XML - Асинхронний Javascript та XML) — підхід до проектування асинхронних веб додатків, при якому замість повного перевантаження сторінки додаток в фоні обмінюється даними з сервером та оновлює користувацький інтерфейс. За рахунок такого підходу покращується взаємодія з користувачем за рахунок значного пришвидшення інтерфейсу, зменшується трафік між сервером та клієнтом.

AJAX не є самостійною технологією, а радше набір технологій та підходів для отримання швидкодіючого асинхронного веб додатку, серед яких асинхронне отримання даних від серверу з Javascript та оновлення DOM-дерева відповідно до відповіді сервера.

Підходи до оновлення DOM-дерева були роглянуті раніше, тому зараз сконцентруємось на асинхронному отриманні даних. Основним з них є використання спеціального об’єкту `XMLHttpRequest`, що дозволяє робити `GET/POST/PUT/DELETE` запити та обробляти відповіді від серверу. Менш популярними є підходи до динамічного додавання тегів `<script>` (або ж `<iframe>` чи `<img>`), наприклад використовуючи jQuery:

    $('body').append('<script type="text/javascript" src="/generated.jsp"></script>');

При цьому браузер після додавання тегу автоматично зробить `GET` запит та підвантажить результати (для інших тегів аналогічно). Очевидно, що такий підхід обмежений тільки `GET` запитами.

Робота з XMLHttpRequest:

    var xmlhttp = window.XMLHttpRequest? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");

    xmlhttp.open("GET", "/fragment.jsp", true);
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            document.write(xmlhttp.responseText);
        } else {
            // process error
        }
    };
    xmlhttp.send(null);

Старі версії IE (5,6) не мають об’єкту `XMLHttpRequest`, для них існує відповідний ActiveX об’єкт - для цього й застосовується перша умова. Однак для справжньої кросбраузерності необхідно ще додаткові перевірки. В даному випадку запит "GET" відправляється асинхронно, що вказує останній параметр функції `open()`. Функція `onreadystatechange` буде викликана коли дані будуть отримані з сервера. Можлива також синхронне завантаження даних, тоді обробка сторінки буде затримана доки не буде завантажена відповідь від серверу (саме тому такий варіант значно рідше використовується):

    var xmlhttp = getXmlHttp()
    xmlhttp.open('GET', '/fragment.jsp', false);
    xmlhttp.send(null);

    if(xmlhttp.status == 200) {
      document.write(xmlhttp.responseText);
    }

Як видно використання AJAX потребує достатньо багато коду, однак використовуючи вже знайому бібліотеку jQuery можливо отримати досить елегантний код. Розглянемо для прикладу таку ситуацію де доцільно використовувати AJAX: на сторінці є статистика користувача, яка досить довго рахується (декілька секунд) й щоб не змушувати користувача очікувати всю сторінку, можливо винести таку статистику у окремий Servlet/JSP й завантажити її пізніше асинхронно. Для цього на сторінці додамо пустий `<div id="user-statistics">`, куди потім будуть завантажені дані, та додамо відповідний скрипт:

    $('#user-statistics').load('/statistics?user=' + userName); 

Даний скрипт у фону відправить запит `GET` запит на URl `'statistics/' + userName` та вставить отриманий фрагмент у елемент з ідентифікатором: `user-statistics`.

При цьому на сервер буде відправлено 2 `GET` запити та елемент статистики якийсь час буде порожнім, однак в цілому сторінка буде завантажуватись візуально значно швидше. Вплив останньої проблеми можна зменшити додавши в оригінальний `<div id="user-statistics">` картинку, що зображатиме процес завантаження:

    <div id="user-statistics">
        <img src="/img/loader.gif" alt="loader" />
    </div>

Серверна частина, що віддаватиме статистику буде повертати тільки фрагмент HTML, наприклад наступним чином:

    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

        PrintWriter out = response.getWriter();
        Statistics stat = userService.getStatistics(request.getParameter("user"));
        out.println("<b>Visits:</b> " + stat.getVisits() + "<br/>");
        out.println("<b>Friends:</b> " + stat.getFriends() + "<br/>");
        out.println("<b>Karma:</b> " + stat.getKarma() + "<br/>");
    }

Більш повний формат функції `load` [з документації](http://api.jquery.com/load/):

    $('#success').load("/statistics", 
        { "user": userName },
        function(response, status, xhr) {
            if (status == "error") {
                var msg = "Sorry but there was an error: ";
                $("#error").html(msg + xhr.status + " " + xhr.statusText);
            }
        }
    );

Перший аргумент - URL, потім об’єкт який буде перетворено в параметри URL (`/statistics?user={userName}`) та функція обробник відповіді або помилки. Можливо також окремо додати обробники для успішної відповіді та помилок:

    jqxhr.done(function(data, textStatus, jqXHR) {
        alert( "second success" );
    })
    .fail(function() {
        alert( "error" );
    })
    .always(function() {
        alert( "finished" );
    });

Розглянемо ще один можливий варіант використання - оновлення частини сторінки по таймеру через `GET` запит, наприклад необхідно постійно показувати актуальне число повідомлень користувачу, навіть якщо він не оновлює всю сторінку. Для чого в Javascript є можливість викликати функцію по таймеру з заданим інтервалом в мілісекундах:

    var timer = setInterval(function() { 

        $.get('/messages', {user: userId})
         .done(function(respText) {
            $('#messages span').html(respText);
         }).fail(function() {
            $('#messages span').html('Failed to load');
         });     

    }, 2000);

Для запиту даних з серверу використано функцію `$.get()`, яка дуже схожа на `load()`, однак дані з серверу нікуди не вставляються, а можуть бути отримані у функції обробнику. Більше прикладів функції можна знайти у [документації](http://api.jquery.com/jQuery.get/).
Стрічка `$('#messages span').html(respText)` знайде елемент з ідентифікатором `messages`, потім знайде в ньому елементи `<span>` та змінить їх HTML вміст на значення `respText`. Серверу як видно достатньо повертати тільки єдине число - кількість повідомлень.
HTML код для даного прикладу:

    <div id="messages">
        Messages: <span>Loading...</span>
    </div>

Для того щоб зупитинити роботу таймера необхідно викликати функцію `clearInterval` з об’єктом, що повернувся в результаті `setInterval`:

    clearInterval(timer);

Для того, щоб відправити `POST` запит існує функція [`$.post`](http://api.jquery.com/jQuery.post/), останнім аргументом є тип, даних що повертає серверна сторона (`html`, `xml`, `text`, `json` та інші):

    $.post("/form.jsp", {login: 'test', password: '111'},
     function( data ) {
      $( ".result" ).html( data );
    }, 'html');

Однак ці функції є лише скороченням для більше загальної [`$.ajax`](http://api.jquery.com/jQuery.ajax/). Дана функція приймає об’єкт, полями якого є параметри запиту (так зроблено, оскільки функція яка має більше 20 аргументів жахливо незручна для викликаючої сторони), наприклад POST запит, який поверне HTML з серверу:

    var xhr = $.ajax({
      url: "script.jsp",
      type: "POST",
      data: { page : 5, max: 20 },
      dataType: "html"
    });
     
    xhr.done(function(data) {
      $("#target").html(data);
    });
     
    xhr.fail(function(jqXHR, textStatus) {
      alert("Request failed: " + textStatus);
    });

Можна додати глобальний обробник всіх помилок AJAX, який наприклад буде показувати суть помилки в наперед визначеному елементі:

    $.ajaxError(function(evt, xhr, settings, error) {
      $("div#status").text("Ajax request failed with error");
    });

Побудова динамічного сайту
------------

Розглянемо приклад побудови повністю динамічного сайту: при запиті головної сторінки будуть отримуватись всі елементи, крім головного вмісту, який потім буде підвантажуватись динамічно в залежності від посилання, яке натиснули. Таким чином весь неосновний вміст сайту - меню, заголовок та нижня частина не будуть постійно завантажуватись з серверу. Для початку розглянемо HTML код:

    <ul>
        <li><a id="page1" class="dynamic" href="/page1" data-target="#content">Перша сторінка</a></li>
        <li><a id="page2" class="dynamic" href="/page2" data-target="#content">Друга сторінка</a></li>
        <li><a id="page3" class="dynamic" href="/page3" data-target="#content">Третя сторінка</a></li>
    </ul>
    <div id="content"></div>

Javascript код, який додасть динамічне завантаження для всіх посилань з класом `dynamic`:
    
    $(function() {
        $('a.dynamic').on('click', function() {
            loadLink($(this));
            return false;
        });

        function loadLink(link) {
            $('a.dynamic.active').removeClass('active');
            link.addClass('active');

            var target = $(link.data('target'));
            target.load(link.attr('href') + '.part');
            window.location.hash = link.attr('id');
        }

        function loadDefault() { ... }

        loadDefault();
    }

Тепер необхідно додати обробник, який при завантаженні сторіки автоматично відкриє посилання з хешу, або ж посилання за замовчуванням:

    function loadDefault() {    
        var hash = window.location.hash;
        var curLink = $("a.dynamic:first");

        if(hash) {
            $(hash).each(function() {
                curLink = $(this);
            });
        }

        loadLink(curLink);
    }

Функція `each` в jQuery для кожного знайденого елементу запускає передану в неї функцію, у якої `this` буде відповідати знайденому DOM-елементу. В даному випадку це функціональний спосіб перевірити чи знадено якесь значення за hash чи ні, й якщо знайдено - занести його до змінної `curLink`. Може бути три варіанти, що певерне `window.location.hash`: 

 1. Значення `hash` буде пустим - тоді `if(hash)` не спрацює й буде використано перше знайдене динамічне посилання.
 2. Значення `hash` буде відповідати посиланню, оскільки функція `window.location.hash` повертає стрічку, яка завжди починається з `#`, тому таку стрічку одразу можливо використати як селектор по ідентифікатору - `#page1` й відповідно буде знайдено посилання яке необхідно активувати.
 3. Користувач сам змінив значення `hash` - тоді такого посилання може не бути, відповідно тоді спрацює перше ж знайдене посилання.

Насправді в даному випадку при першому завантаженні робота сайту навіть погіршилась - оскільки тепер користувачу необхідно очікувати 
2 запити - один який завантажить основну сторінку й тільки після її завантаження ще один - який завантажить вміст. Однак після цього всі інші сторінки відкриватимуться значно швидше. Тому додавання AJAX не завжди доцільно - потрібно знати як користувач використовує ваш сайт - якщо користувачі рідко переходять по сторінкам сайту - додавання AJAX може зашкодити.

> Twitter, які з самого початку дуже активно використовували схожу модель для побудови інтерфейсу сайту, через кілька років повернулись до звичайної моделі - при першому завантаженні сторінка віддається сервером повністю, а далі деякі елементи можуть вже підвантажуватись через AJAX. Оскільки користувачі сильно жалілись на повільність Twitter. 

В даному прикладі також можливо додати кешування сторінок на клієнті, наприклад створити глобальну змінну `cache` і перед завантаженням сторінки через `load` - перевіряти чи є таке значення в об’єкті кешу: `cache[link.attr('id')] !== undefined` - якщо є не завантажувати дані з серверу, якщо ж немає - то після успішного завантаження занести їх у кеш. Тоді після першого перегляду всіх сторінок користувачу їх не потрібно буде взагалі завантажувати з серверу. Однак для більш комфортної роботи користувача потрібно попіклуватись також щоб кеш через якийсь час скидався й обмежити його за розмірами - оскільки він може відбирати дуже багато оперативної пам’яті користувача.

Основною перевагою підходу AJAX є повністю зміна моделі взаємодії з користувачем за рахунок значного зменшення часу реакції інтерфейсу - тепер не обов’язково перезавантажувати всю сторінку для оновлення даних. З останнього також випливає те, що з’являється можливість просто зберігати деякі дані в javascript на клієнтській стороні, наприклад кешуючи запити від сервера. 

Також з AJAX з’являється можливість додавати більше інтерактиву до сайту, так, наприклад, сайт може показувати підсказки та доповнення отримані з серверу вже під час введення даних користувачем.

Все ці переваги дозволяють реалізовувати веб додатки, які по взаємодії будуть нагадувати звичайні desktop додатки й при цьому такий додаток не потрібно встановлювати й досить легко оновлювати. 

Також значно зменшуються обсяги трафіку між клієнтом та сервером й навантаження на сам сервер - йому тепер достатньо віддавати тільки малі порції даних, які потім відформатуються на клієнті, ну і знову ж таки можуть бути взагалі закешовані на клієнті. Дії користувача можуть відправлятись окремими запитами на сервер й сторінка при цьому не перевантажуватиметься.

Однак AJAX як підхід та технології, що в ньому використовуються мають й слабкі місця, основним з яких є те, що динамічні елементи сторінки ніяк не реєструються браузером - URL не змінюється й відповідно відмічається в історії браузера, неможливо передати чи зберегти посилання в закладки щоб повернутись до нього ще раз. Або ж згадайте як довго доводиться прокручувати блоги з динамічним підвантаженням записів по скролу щоб знайти минулорічний запис (хоча причина тут зазвичай не в AJAX, а в тому щоб зробити складнішим доступ до старих записів у БД, які можуть знаходитись на повільних носіях). Якщо на сторінках сайту були форми, то їх також доведеться обробляти за допомогою Javascript, оскільки вони призводитимуть до перезавантаження сторінки.

Зазвичай цей недолік можна успішно вирішити використовуючи `window.location.hash` - щоб змінювати частину URL після знаку `#`, як у прикладі вище, або ж новіший об’єкт `History.pushState` - щоб повністю змінювати URL (так працюють зараз github.com, vk.com, та багато інших). Однак це значно ускладнює клієнтську архітектуру додатку, тому часто ігнорується розробниками або повністю або ж частково. 

Також достатньо й інших проблем - необхідно щоб у браузерах з підтримувався Javascript, також динамічний вміст не доступний пошуковикам (пошукові машини не будуть виконувати Javascript) - тому розробнику необхідно окремо про них подбати, якщо непродумано використовувати AJAX - то такий сайт в результаті може працювати навіть повільніше за звичайний.

AJAX також досить часто використовується зловмисниками для протиправних дій (наприклад CSRF), тому браузери обмежують `XMLHttpRequest` запити лише до доменого імені, з якого завантажена сторінка зі скриптом. 
